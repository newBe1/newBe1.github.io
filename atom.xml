<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newbe1.github.io/</id>
    <title>YAN · RUI</title>
    <updated>2020-01-23T10:27:28.322Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newbe1.github.io/"/>
    <link rel="self" href="https://newbe1.github.io/atom.xml"/>
    <subtitle>青年 | 才俊</subtitle>
    <logo>https://newbe1.github.io/images/avatar.png</logo>
    <icon>https://newbe1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, YAN · RUI</rights>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>https://newbe1.github.io/post/ji-he</id>
        <link href="https://newbe1.github.io/post/ji-he">
        </link>
        <updated>2020-01-13T06:05:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="集合">集合</h1>
<p>ArrayList和LinkedList 不是同步的  线程不安全</p>
<p>ArrayList底层使用数组 LinkedList底层是双向链表</p>
<p>ArrayList的增删受时间复杂度影响 LinkedList则不受（不支持高效的随机元素访问）</p>
<h2 id="hashtable">HashTable</h2>
<p>HashTable底层是数组和链表结合在一起实现的，key和value都不能为null（空指针异常），线程安全（修改数据时锁住整个HashTable）效率低，ConcurrentHashMap做了相关优化</p>
<h2 id="hashmap">HashMap</h2>
<p>底层是数组和链表实现的，key和value都可以为null，线程不安全</p>
<h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<p>底层采用数组和链表实现，线程安全，key和value不能为null（空指针异常）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring]]></title>
        <id>https://newbe1.github.io/post/spring</id>
        <link href="https://newbe1.github.io/post/spring">
        </link>
        <updated>2020-01-13T06:05:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring">spring</h1>
<h2 id="注解">注解</h2>
<h3 id="springbootapplication">@SpringBootApplication</h3>
<p>@SpringBootConfiguration:等同于spring 的xml配置文件</p>
<p>@EnadleAutoConfiguration: 自动配置</p>
<p>@ComponentScan:组件扫描 自动发现和配置一些Bean</p>
<h3 id="restcontroller"><strong>@RestController</strong></h3>
<p>@Controller和@ResponseBody的合集 表示这个是控制器bean 是REST风格的控制器</p>
<h2 id="基本信息">基本信息</h2>
<p>![](C:\Users\22215\Pictures\Saved Pictures\936870-20160922153752027-1272044443.png)</p>
<p><strong>Spring框架的核心就是IoC（控制反转）和AOP（面向切面编程）</strong></p>
<h2 id="特点">特点</h2>
<ol>
<li>方便解耦,简化开发(IOC)</li>
<li>方便集成各种框架</li>
<li>低入侵性,无需实现spring的接口就可以使用其中封装的方法</li>
<li>面向切面编程aop</li>
</ol>
<h2 id="spring-ioc">spring IOC</h2>
<p>将创建对象的工作反转交给spring ioc容器 , 对代码进行解耦</p>
<p>传统模式下我们通过new的方法创建对象,这样的做法使代码的耦合度高,spring利用ioc容器统一去管理和创建对象,由ioc控制外部资源对该对象或文件的获取.</p>
<h3 id="容器生成方法">容器生成方法</h3>
<p><strong>方法一:</strong> ioc使用反射机制通过工厂模式读取xml文件创建一个JavaBean容器来管理对象(工厂模式解耦)这个接口为BeanFactory</p>
<p>读取配置文件时不会创建对象,只在用时创建( 延迟实例化 )</p>
<ul>
<li>应用启动的时候占用资源很少适用于对资源要求较高的应用</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object getBean(String name) throws BeansException;<T> T getBean(String name, Class<T> requiredType) throws BeansException;Object getBean(String name, Object... args) throws BeansException;<T> T getBean(Class<T> requiredType) throws BeansException;<T> T getBean(Class<T> requiredType, Object... args) throws BeansException;</td>
<td>多个getBean的方法，可以通过Bean的name（by name），也可以通过bean的类型（by type）。</td>
</tr>
<tr>
<td>boolean containsBean(String name);</td>
<td>是否包含Bean</td>
</tr>
<tr>
<td>boolean isSingleton(String name) throws NoSuchBeanDefinitionException;</td>
<td>Bean是否是单例，这里需要注意的是，默认情况下，Bean都是以单例形式存在的，与其相反的是原型模式的Bean，当我们创建了一个原型模式下的Bean，IoC容器就会创建一个新的Bean返回给调用者，这与Bean的作用域有关。</td>
</tr>
<tr>
<td>boolean isPrototype(String name) throws NoSuchBeanDefinitionException;</td>
<td>Bean是否是原型，也就是&quot;多例&quot;</td>
</tr>
<tr>
<td>boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException;</td>
<td>是否类型匹配</td>
</tr>
<tr>
<td>Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;</td>
<td>获取Bean的类型</td>
</tr>
<tr>
<td>String[] getAliases(String name);</td>
<td>获取Bean的别名</td>
</tr>
</tbody>
</table>
<p><strong>方法二:</strong> 在Spring的发展中，在BeanFactory的基础上，还设计了一个更为高级的接口，ApplicationContext，它通过继承上级接口进而继承BeanFactory，它在BeanFactory的基础上，扩展了消息国际化接口(MessageSource)、环境可配置接口(EnvironmentCapable)、应用事件接口(ApplicationEventPublisher)和资源模式解析接口(ResourcePatternResolver)。那么，BeanFactory有的方法ApplicationContext自然也会有，后面的示例就直接用ApplicationContext进行。</p>
<p>ApplicationContext接口有以下3个常用实现类，可以实例化任何一个类来创建Spring的ApplicationContext容器。</p>
<p>读取配置文件生成容器的时候就会创建对象( 不延迟实例化 )</p>
<ul>
<li>所有的Bean在启动的时候都加载，系统运行的速度快；</li>
<li>在启动的时候所有的Bean都加载了，我们就能在系统启动的时候，尽早的发现系统中的配置问题</li>
<li>建议web应用，在启动的时候就把所有的Bean都加载了。（把费时的操作放到系统启动中完成)</li>
</ul>
<table>
<thead>
<tr>
<th>ApplicationContext实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ClassPathXmlApplicationContext</td>
<td>它可以从当前类路径中检索配置文件并装载它来创建容器的实例</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>它和ClassPathXmlApplicationContext唯一的区别在于读取配置文件的方式，它不在从类路径下获取配置文件，它可以通过指定位置的方式读取配置文件，还可以获取类路径之外的资源</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>它一般在使用注解方式配置Bean的时候，通过指定配置类的方式创建容器实例</td>
</tr>
</tbody>
</table>
<p>总结:</p>
<ul>
<li>ApplicationContext 适用于创建单例对象 , BeanFactory适用于创建多例对象</li>
</ul>
<h3 id="模仿的一个beanfactory类"><strong>模仿的一个BeanFactory类</strong></h3>
<pre><code class="language-java">public class BeanFactory {

    //定义一个properties对象
    private static Properties props;

    //定义一个map 用来存储配置文件种的key-value 就是容器
    private static Map&lt;String, Object&gt; beans;

    //使用静态代码块 为props赋值
    static {
        try {
            //实例化properties对象
            props = new Properties();
            //获取配置文件的流对象  在入系统中的所有Resource文件
            InputStream is = BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;);
            props.load(is);
            //实例化容器
            beans = new HashMap&lt;String, Object&gt;();
            //取出配置文件中的值
            Enumeration keys = props.keys();
            //遍历枚举
            while (keys.hasMoreElements()){
                String key = keys.nextElement().toString();
                //反射建立对象
                Object value = Class.forName(props.getProperty(key)).newInstance();
                //将key-value存入容器
                beans.put(key,value);
            }
        } catch (Exception e) {
            throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;);
        }
    }

    //获取配置文件值
    public static Object get(String key){
        return beans.get(key);
    }

//    public static void main(String[] args) {
//        System.out.println(get(&quot;IAccountDao&quot;));
//    }
}
</code></pre>
<p>创建bean.properties</p>
<pre><code class="language-java">IAccountDao=com.yan.dao.impl.AccountDaoImpl
IAccountService=com.yan.service.impl.AccountServiceImpl 
</code></pre>
<p>创建对象</p>
<pre><code class="language-java">//IAccountDao iAccountDao = new IAccountDao()
IAccountDao iAccountDao = (IAccountDao)BeanFactory.get(&quot;IAccountDao&quot;);  //此对象为单例对象只被创建一次




public class AccountDaoImpl implements IAccountDao{
    int i =0 ;
    public void saveDao() {
        for (int a =0 ; a &lt;3 ; a ++){
            System.out.println(i);
            i++;
            System.out.println(&quot;保存成功&quot;);
        }
    }
}
//
输出0
保存成功
1
保存成功
2
保存成功
单例对象中的成员变量也就初始化一次
</code></pre>
<ul>
<li>
<p>注解</p>
<p>JavaBean : 可重用组件 用来创建service和dao对象</p>
<p>在配置文件中配置service和dao对象  格式(唯一标识符=权限定类名)</p>
<p>ioc创建的对象默认是单例对象( 当scope设置为prototype的时为多例   <em><strong>@Scope(value=&quot;prototype&quot;</strong>) //创建多实例</em>  )</p>
<p>***singleton（单例）***:共享一个实例对象,对象类中的成员变量也只会初始化一次(节约资源)</p>
<p><em><strong>prototype（多例）</strong></em> :对这个bean的每次请求都会创建一个新的bean实例 (防止并发问题线程安全) ,当一个bean是多例模式的情况下，lazy-init为false或者default无效</p>
<p><u>使用标准</u>:当对象在请求中会被改变状态的话(存在类成员变量)就使用多例,反之单例</p>
<p>举例: 数据库连接池就是单例模式，有且仅有一个连接池管理者，管理多个连接池对象。</p>
</li>
</ul>
<h3 id="ioc的两种使用方法xml配置-注解">IOC的两种使用方法(xml配置  注解)</h3>
<h4 id="xml配置"><strong>xml配置</strong></h4>
<p>通过在xml文件中配置bean标签进行依赖和注入:</p>
<ol>
<li>
<p><strong>bean标签作用</strong></p>
<p>用于配置spring容器管理bean对象</p>
</li>
<li>
<p><strong>bean标签的属性</strong></p>
<ul>
<li>
<p>id：给对象在容器中提供一个唯一标识。用于获取对象。</p>
</li>
<li>
<p>class：指定类的全限定名。用于反射创建对象。默认情况下调用无参构造函数,若没有无参构造方法则无法创建对象</p>
</li>
<li>
<p>scope：指定对象的作用范围。</p>
</li>
<li>
<p>singleton：默认值，单例的（在整个容器中只有一个对象）.</p>
<ul>
<li>prototype：多例的</li>
<li>request：将Spring 创建的 Bean 对象存入到 request 域中.</li>
<li>session：将Spring 创建的 Bean 对象存入到 session 域中.</li>
<li>global session：WEB 项目中,应用在 Portlet 环境.如果没有 Portlet 环境那么globalSession 相当于 session。</li>
</ul>
</li>
<li>
<p>init-method：指定类中的初始化方法名称。</p>
</li>
<li>
<p>destroy-method：指定类中销毁方法名称。比如DataSource的配置中一般需要指定destroy-method=“close”。</p>
</li>
<li>
<p>lazy-init：ApplicationContext实现的默认行为就是在启动时将所有 singleton bean进行实例化。</p>
</li>
<li>
<p>lazy-init可以延迟初始化，设置lazy-init=&quot;true&quot;使得Ioc容器在第一次需要bean的时候进行实例化。</p>
</li>
</ul>
</li>
<li>
<p><strong>bean标签的作用范围</strong></p>
</li>
</ol>
<p>通过在xml的bean标签的scope进行配置</p>
<table>
<thead>
<tr>
<th style="text-align:center">作用域</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">singleton</td>
<td style="text-align:left">单例模式，singleton是默认的作用域，当定义Bean时没有指定scope配置项，Bean的作用域被默认为singleton。singleton属于单例模式，在整个系统上下文环境中，仅有一个Bean实例。</td>
</tr>
<tr>
<td style="text-align:center">prototype</td>
<td style="text-align:left">原型模式，当一个Bean的作用域被定义prototype时，程序每次从IOC容器获取的Bean都是一个新的实例。</td>
</tr>
<tr>
<td style="text-align:center">request</td>
<td style="text-align:left">http请求，bean作用于HTTP request生命周期，每个request有通过bean创建的实例。</td>
</tr>
<tr>
<td style="text-align:center">session</td>
<td style="text-align:left">会话，bean作用于session生命周期。</td>
</tr>
<tr>
<td style="text-align:center">global-session</td>
<td style="text-align:left">全局会话，bean作用于全局的session生命周期。</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>
<p><strong>bean的三种实例化方法</strong></p>
<p>无参构造 (若对象中无 无参构造方法则实例化失败)</p>
<pre><code class="language-xml">&lt;bean id=&quot;wanger&quot; class=&quot;com.luis.dto.Person&quot;&gt;&lt;/bean&gt; 
</code></pre>
<p>静态工厂(通过静态工厂中提供的方法实例化对象)</p>
<pre><code class="language-xml">&lt;bean id=&quot;person&quot; class=&quot;com.luis.factory.StaticFactory&quot; factory-method=&quot;createPerson&quot;/&gt;
</code></pre>
<p>实例工厂  (先实例化工厂再使用工厂中的方法实例化需要的对象)</p>
<pre><code class="language-xml">&lt;bean id=&quot;instancFactory&quot; class=&quot;com.luis.factory.PersonFactory&quot;/&gt;
&lt;bean id=&quot;person&quot; factory-bean=&quot;instancFactory&quot; factory-method=&quot;createPerson&quot;/&gt;
</code></pre>
</li>
</ol>
<p>5.<strong>依赖注入</strong></p>
<p>带参方法注入</p>
<pre><code class="language-xml">&lt;bean id=&quot;IAccountService&quot; class=&quot;com.yan.service.impl.AccountServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;afas&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
<p>set方法注入</p>
<pre><code class="language-xml">&lt;bean id=&quot;IAccountService&quot; class=&quot;com.yan.service.impl.AccountServiceImpl&quot; scope=&quot;prototype&quot;&gt;
        &lt;property name=&quot;namefa&quot; value=&quot;张氏&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;age&quot; value=&quot;12&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<p>p名称空间注入</p>
<pre><code class="language-xml">&lt;bean id=&quot;IAccountService&quot; class=&quot;com.yan.service.impl.AccountServiceImpl&quot; p:name=&quot;zhangs&quot; p:age=&quot;12&quot; p:date-ref=&quot;now&quot;&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
</code></pre>
<h4 id="注解-2">注解</h4>
<ol>
<li><strong>bean标识注解</strong></li>
</ol>
<ul>
<li>@Component : 组件通用注解  常用于model类</li>
<li>@Controller : 常用于对controller控制类进行标注</li>
<li>@Service : 常用于对Service类进行标注</li>
<li>@ Repository : 常用于对dao类进行标注</li>
</ul>
<p>这些注解功能一样都是用来创建bean对象的,可以互换,不同的业务层使用不同的注解使业务逻辑更加清晰</p>
<ol start="2">
<li><strong>bean属性注入</strong></li>
</ol>
<ul>
<li>@Value ：注入普通类型属性</li>
<li>@Resource ：注入对象类型</li>
<li>@Autowired ：注入对象类型，默认按照类型注入。结合@Qualifier注解完成按名称的注入。</li>
</ul>
<ol start="3">
<li><strong>bean的作用范围注解@Scope</strong></li>
</ol>
<ul>
<li>加在类上控制创建的类是单例还是多例的(默认单例)</li>
<li>@Scope取值
<ul>
<li>singleton ：单例</li>
<li>prototype ：多例</li>
<li>request ：request域，需要在web环境</li>
<li>session ：session域，需要在web环境</li>
<li>application： context域，需要在web环境</li>
<li>globalsession 集群环境的session域，需要在web环境</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>bean的生命周期注解</strong></li>
</ol>
<ul>
<li>@PostConstruct ：相当于init-method</li>
<li>@PreDestroy ：相当于destroy-method</li>
</ul>
<p><strong>例子</strong></p>
<pre><code class="language-java">@Component(value = &quot;accountService&quot;)
public class AccountServiceImpl implements IAccountService {

    @Value(&quot;zhangs&quot;)
    private String name;

    @Value(&quot;12&quot;)
    private Integer age;

    private Date date;


    //name 和 User对象的注入ioc的唯一标识符相同  User类中@Component(&quot;user&quot;)
    //    @Qualifier(&quot;user&quot;)
    //    @Autowired   效果一致
    @Resource(name = &quot;user&quot;)
    private User user;

    public AccountServiceImpl(String name,Integer age , Date date , User user) {
        this.name = name;
        this.age = age;
        this.date = date;
        this.user = user;
        System.out.println(&quot;带参构造对象&quot;);
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public AccountServiceImpl() {
        System.out.println(&quot;无参构造对象&quot;);
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    //private IAccountDao iAccountDao=null;
    public void save() {
//            iAccountDao =  (IAccountDao) BeanFactoryDiy.get(&quot;IAccountDao&quot;);
//            iAccountDao.saveDao();
            System.out.println(&quot;保存成功&quot;);
    }

    @Override
    public String toString() {
        return &quot;AccountServiceImpl{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, date=&quot; + date +
                &quot;, user=&quot; + user +
                '}';
    }

    @PostConstruct
    public void init(){
        System.out.println(&quot;初始化方法-----&quot;);
    }

    @PreDestroy
    public void destory(){
        System.out.println(&quot;销毁方法------&quot;);
    }
}
</code></pre>
<pre><code class="language-java">@Component(&quot;user&quot;)
public class User {

    @Value(&quot;root&quot;)
    private String username;

    @Value(&quot;root&quot;)
    private String password;

    public User() {
        System.out.println(&quot;无参构建user&quot;);
    }

    public User(String username , String password) {
        this.username = username;
        this.password = password;
        System.out.println(&quot;带参构建user&quot;);
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;username='&quot; + username + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }
}

</code></pre>
<h2 id="spring-aop"><strong>spring AOP</strong></h2>
<p>针对目标对象进行动态代理</p>
<p>aop的动态代理是Cglib代理（aop的原理也是动态代理  从spring boot 2.0后 默认Cglib代理  之前是有JDK代理的）</p>
<p>PointCut(切点)：真正使用aop的方法</p>
<p>Advice(通知)：定义aop何时被调用 以及执行的方法</p>
<p>JoinPoint(链接点)：可以使用aop的地方（方法的前后）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库]]></title>
        <id>https://newbe1.github.io/post/shu-ju-ku</id>
        <link href="https://newbe1.github.io/post/shu-ju-ku">
        </link>
        <updated>2020-01-12T10:49:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据库">数据库</h1>
<h2 id="数据库性能优化"><strong>数据库性能优化</strong></h2>
<p><em>sql优化</em>：</p>
<p>​			少使用select*；</p>
<p>​			只查询一条记录时使用 limit 1；</p>
<p>​			使用连接查询代替子查询；</p>
<p>​			尽量使用一些能通过索引查询的关键字；</p>
<p><em>表结构优化</em>：</p>
<p>​			尽量使用数字类型的字段，提高比对效率；</p>
<p>​			长度不变且对查询速度要求高的数据可以考虑使用 char，否则使用 varchar；</p>
<p>​			表中字段过多时可以适当的进行垂直分割，将部分字段移动到另外一张表；</p>
<p>​			表中数据量过大可以适当的进行水平分割，将部分数据移动到另外一张表。</p>
<p><em>其他优化</em>：</p>
<p>​			 对查询效率高的字段适当建立索引提高效率；</p>
<p>​			根据表的用途使用合适的数据库引擎，读写分离；</p>
<h3 id="索引"><strong>索引</strong></h3>
<p><u>like以%开头会导致索引失效而进行全局扫描</u></p>
<p>mysql查询的方式 即访问类型有</p>
<p>ALL：全表扫描</p>
<p>index：索引全扫描</p>
<p>range：索引范围扫描</p>
<p>ref：使用非唯一索引扫描</p>
<p>eq_ref：使用唯一索引扫描</p>
<p>const，system：单表中 最多只有一个匹配行</p>
<p>（性能越来越好）</p>
<p><strong>作用</strong></p>
<p>快速访问表中的特定信息，提高查询速度</p>
<p>创建唯一索引，确保数据的唯一性</p>
<p>加速表和表之间的联系</p>
<p>减少查询中分组和排序的时间</p>
<p><strong>分类</strong></p>
<p>主键索引（PRIMAY KEY）</p>
<p>唯一索引（UNIQUE）</p>
<p>常规索引（INDEX）</p>
<p>全文索引（FULLTEXT）</p>
<p><strong>负面影响</strong></p>
<p>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加，同时索引也需要占用物理空间，当对表进行操作的时候索引也要进行动态维护，会降低数据的维护速度</p>
<p><strong>创建索引的原则</strong></p>
<p>在频繁使用，用以缩小查询范围的字段或者用以排序的字段上建立索引</p>
<p>对应很少涉及查询的列或重复值较多的列，不宜创建索引</p>
<p>对于特殊的数据类型的列，不宜创建索引如（text）</p>
<h3 id="mysql的事务隔离级别"><strong>MySql的事务隔离级别</strong></h3>
<p><strong>Read uncommitted</strong>  ：读未提交  <u><strong>脏读</strong></u> 一个事务可以读取另一个未提交的事务的数据  可用读提交解决</p>
<p><strong>Read committed</strong> ：读提交  一个事务要等另一个事务提交后才能读取数据，但会出现一个事务范围内两个相同的查询出现不同的结果 这就是 <u><strong>不可重复读</strong></u> ，可用重复读解决这个问题</p>
<p><strong>Repeatable read</strong> ：重复读 在开始读取数据时（事务开启时） ， 不容许修改操作，可能出现<strong>幻读</strong> 当用户读取某一范围的数据行时，另一个事务又在该范围插入了新数据，用户再读取该范围的数据时会出现幻影行 <strong>Mysql的默认事务隔离级别</strong></p>
<p><strong>Serializable</strong> ：串行化 序列化 一个事务一个事务地执行，<strong>会导致大量超时现象和锁竞争</strong></p>
<p><u>不可重复读主要侧重于修改，幻读主要侧重于增删。解决不可重复读锁住满足条件的行，解决幻读需锁表</u></p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交（read uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读提交（read committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>重复度（repeatable read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="mysql锁概述">MySql锁概述</h3>
<p>**表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>
**行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>
**页面锁：**开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>不同的存储引擎支持不同的锁机制</p>
<p>MyISAM和MEMORY采用表级锁</p>
<p>BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁</p>
<p>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁</p>
<h3 id="五大约束">五大约束</h3>
<p>1.—-主键约束（Primay Key Coustraint） 唯一性，非空性</p>
<p>2.—-唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个</p>
<p>3.—-检查约束 (Check Counstraint) 对该列数据的范围、格式的限制（如：年龄、性别等）</p>
<p>4.—-默认约束 (Default Counstraint) 该数据的默认值</p>
<p>5.—-外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列</p>
<p><em><strong>示例</strong></em></p>
<p>五大约束的语法示例</p>
<p>1.—-添加主键约束（将stuNo作为主键）</p>
<p>alter table stuInfo</p>
<p>add constraint PK_stuNo primary key (stuNo)</p>
<p>2.—-添加唯一约束（身份证号唯一，因为每个人的都不一样）</p>
<p>alter table stuInfo</p>
<p>add constraint UQ_stuID unique(stuID)</p>
<p>3.—-添加默认约束（如果地址不填 默认为“地址不详”）</p>
<p>alter table stuInfo</p>
<p>add constraint DF_stuAddress default (‘地址不详’) for stuAddress</p>
<p>4.—-添加检查约束 （对年龄加以限定 15-40岁之间）</p>
<p>alter table stuInfo</p>
<p>add constraint CK_stuAge check (stuAge between 15 and 40)</p>
<p>alter table stuInfo</p>
<p>add constraint CK_stuSex check (stuSex=’男’ or stuSex=’女′)</p>
<p>5.—-添加外键约束 (主表stuInfo和从表stuMarks建立关系，关联字段stuNo)</p>
<p>alter table stuInfo</p>
<p>add constraint FK_stuNo foreign key(stuNo)references stuinfo(stuNo)</p>
<h1 id="linux安装mysql">Linux安装mysql</h1>
<h2 id="1检查操作系统是否自带mysql">1.检查操作系统是否自带mysql</h2>
<pre><code>[root@localhost local]# rpm -qa|grep mysqlmysql-libs-5.1.73-8.el6_8.x86_64
</code></pre>
<p>比如我这里自带了一个mysql。</p>
<p>使用yum命令，因为yum命令可以自动删除与mysql相关的依赖；如果使用rpm命令，则还需要手动去删除和mysql相关的文件</p>
<pre><code>[root@localhost local]# yum -y remove mysql-libs-5.1.73-8.el6_8.x86_64
</code></pre>
<p>检查删除是否成功。如果没有提示则删除成功。</p>
<pre><code>[root@localhost local]# rpm -qa|grep mysql
</code></pre>
<h2 id="2下载mysql57">2.下载mysql5.7</h2>
<p>mysql官网 https://dev.mysql.com/downloads/mysql/5.7.html#downloads</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20180811133327731?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>将下载的安装包&quot;mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz&quot;利用xftp上传至**/usr/local**下</p>
<p>解压</p>
<pre><code>[root@localhost local]# tar -zxvf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdn.net/20180811133512504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>顺手删除mysql5.7的源码包</p>
<pre><code>[root@localhost local]# rm -f mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz
</code></pre>
<p>修改文件名</p>
<pre><code>[root@localhost local]# mv mysql-5.7.21-linux-glibc2.12-x86_64/ mysql57
</code></pre>
<p>进入/mysql57创建data文件夹</p>
<pre><code>[root@localhost local]# cd mysql57/[root@localhost mysql57]# mkdir data
</code></pre>
<h2 id="3创建mysql用户组和mysql用户">3.创建mysql用户组和mysql用户</h2>
<pre><code>#查看有没有mysql组[root@localhost mysql57]# cat /etc/group | grep mysql查看有没有mysql用户[root@localhost mysql57]# cat /etc/passwd |grep mysql若没有则创建mysql组#创建mysql用户组[root@localhost mysql57]# groupadd mysql#创建mysql用户并添加到mysql用户组中(//useradd -r参数表示mysql用户是系统用户，不可用于登录系统；第一个mysql是用户组，第二个mysql是用户) [root@localhost mysql57]# useradd -r -g mysql mysql#检查用户组是否创建成功[root@localhost mysql57]# groups mysql
</code></pre>
<h2 id="4设置mysql目录访问权限用户组">4.设置mysql目录访问权限，用户组</h2>
<pre><code>#将mysql目录访问权限赋为myql用户[root@localhost mysql57]# chown -R mysql /usr/local/mysql57#改变mysql目录的用户组属于mysql组[root@localhost mysql57]# chgrp -R mysql /usr/local/mysql57#查看mysql目录下所有的目录及文件夹所属组合用户[root@localhost mysql57]# cd /usr/local/mysql57[root@localhost mysql57]# lltotal 56drwxr-xr-x  2 mysql mysql  4096 Aug 11 21:24 bin-rw-r--r--  1 mysql mysql 17987 Dec 28  2017 COPYINGdrwxr-xr-x  2 mysql mysql  4096 Aug 11 21:40 datadrwxr-xr-x  2 mysql mysql  4096 Aug 11 21:24 docsdrwxr-xr-x  3 mysql mysql  4096 Aug 11 21:23 includedrwxr-xr-x  5 mysql mysql  4096 Aug 11 21:24 libdrwxr-xr-x  4 mysql mysql  4096 Aug 11 21:23 man-rw-r--r--  1 mysql mysql  2478 Dec 28  2017 READMEdrwxr-xr-x 28 mysql mysql  4096 Aug 11 21:24 sharedrwxr-xr-x  2 mysql mysql  4096 Aug 11 21:24 support-files
</code></pre>
<p>权限被修改</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdn.net/20180811135338835?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<h2 id="5配置mysql">5.配置mysql</h2>
<p>创建以下文件，设置访问权限，用于mysql配置中</p>
<p>第一步：创建文件/tmp/mysql.sock。并设置权限</p>
<p>创建文件</p>
<pre><code>[root@localhost mysql57]# mkdir tmp[root@localhost mysql57]# cd tmp[root@localhost tmp]# lltotal 0[root@localhost tmp]# touch mysql.sock[root@localhost tmp]# lltotal 0-rw-r--r-- 1 root root 0 Aug 11 21:59 mysql.sock
</code></pre>
<p>设置权限</p>
<pre><code>[root@localhost tmp]# chown -R mysql:mysql /usr/local/mysql57/tmp/mysql.sock[root@localhost tmp]# chmod 755 /usr/local/mysql57/tmp/mysql.sock
</code></pre>
<p>第二步：创建/log/mysqld.log。并设置权限</p>
<pre><code>[root@localhost mysql57]# mkdir log[root@localhost mysql57]# cd log[root@localhost log]# lltotal 0[root@localhost log]# touch mysqld.log[root@localhost log]# chown -R mysql:mysql /usr/local/mysql57/log/mysqld.log[root@localhost log]# chmod 755 /usr/local/mysql57/log/mysqld.log
</code></pre>
<p>如果出错，说明路径没有写全，要写绝对路径</p>
<p>第三步：创建/tmp/mysqld.pid。并设置权限</p>
<pre><code>[root@localhost log]# cd ../tmp[root@localhost tmp]# touch mysqld.pid[root@localhost tmp]# chown -R mysql:mysql /usr/local/mysql57/tmp/mysqld.pid [root@localhost tmp]# chmod 755 /usr/local/mysql57/tmp/mysqld.pid 
</code></pre>
<h2 id="6初始化mysql">6.初始化mysql</h2>
<pre><code>[root@localhost mysql57]# bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql57/ --datadir=/usr/local/mysql57/data/
</code></pre>
<p>可能会报错。报错信息</p>
<pre><code>bin/mysqld: error while loading shared libraries: libnuma.so.1: cannot open shared object file: No such file or directory
</code></pre>
<p>解决方法：<br>
原因：<br>
yum安装的是libnuma.so.1，但安装时默认安装的是32的，而db2需要的是64位的<br>
1.如果已经安装了libnuma.so.1，先yum remove libnuma.so.1</p>
<pre><code>[root@localhost mysql57]# yum remove libnuma.so.1
</code></pre>
<p>2.安装依赖包 yum -y install numactl.x86_64</p>
<pre><code>[root@localhost mysql57]# yum -y install numactl.x86_64
</code></pre>
<p>安装完成后重新，执行</p>
<pre><code>[root@localhost mysql57]# bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql57/ --datadir=/usr/local/mysql57/data/
</code></pre>
<p>安装成功</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdn.net/20180811144440951?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>配置SSL参数（在mysql目录下）</p>
<pre><code>[root@localhost mysql57]# bin/mysql_ssl_rsa_setup --datadir=/usr/local/mysql57/data/
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdn.net/20180811144745248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>由于mysql-5.7.23版本my.cnf不在/support-files下，故我们创建my.cnf文件。</p>
<pre><code>[root@localhost mysql57]# touch /etc/my.cnf[root@localhost mysql57]# vim /etc/my.cnf
</code></pre>
<p>复制如下内容（每个人安装路径可能不一样，需要修改）：</p>
<pre><code>[mysqld]character_set_server=utf8init_connect='SET NAMES utf8'basedir=/usr/local/mysql57datadir=/usr/local/mysql57/dataport = 3306socket=/tmp/mysql.socklog-error=/usr/local/mysql57/log/mysqld.logpid-file=/usr/local/mysql57/tmp/mysqld.pid#表名不区分大小写lower_case_table_names = 1max_connections=5000sql_mode=STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
</code></pre>
<p>配置完成</p>
<h2 id="7启动mysql">7.启动mysql</h2>
<h3 id="方式一">方式一</h3>
<pre><code>[root@localhost mysql57]# bin/mysqld_safe --user=mysql &amp;
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdn.net/20180811145534278?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>查看mysql的运行情况</p>
<pre><code>[root@localhost mysql57]# ps -ef |grep mysql
</code></pre>
<p>第一我没有成功，因为我有个地方出问题了。我在方式二配置成功。</p>
<h3 id="方式二">方式二</h3>
<p><strong>配置mysql自动启动（可根据需要配置）</strong></p>
<pre><code>[root@localhost mysql57]# cp support-files/mysql.server /etc/init.d/mysql[root@localhost mysql57]# vim /etc/init.d/mysql
</code></pre>
<p>添加配置（<strong>i</strong> 进入编辑；<strong>esc--&gt; :wq</strong>保存退出）</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdn.net/20180811151743694?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>若配置了mysql自启动方式则可以使用服务方式启动mysql</p>
<pre><code>#查看mysql状态/etc/init.d/mysql status 或者 service mysql status#启动mysql/etc/init.d/mysql start 或者 service mysql start#停止mysql/etc/init.d/mysql stop 或者 service mysql stop#重新启动mysql/etc/init.d/mysql restart 或者 service mysql restart查看mysql服务说明启动成功ps -ef|grep mysql
</code></pre>
<p>启动mysql</p>
<pre><code>[root@localhost tmp]# service mysql startStarting MySQL. ERROR! The server quit without updating PID file (/usr/local/mysql57/tmp/mysqld.pid).
</code></pre>
<p>报错了，上面说没有/usr/local/mysql57/tmp/mysqld.pid。</p>
<p>解决方案：</p>
<p>a)创建文件/usr/local/mysql57/tmp/mysqld.pid</p>
<p>b)修改权限</p>
<p>修改存放mysqld.pid文件目录的权限</p>
<pre><code>chown -R mysql /usr/local/mysql57/tmpchgrp -R mysql /usr/local/mysql57/tmpchmod 777 /usr/local/mysql57/tmp
</code></pre>
<p>重新启动成功（如果还不行，就是中间某个步骤写错了。或者直接把mysql目录权限赋为777）</p>
<pre><code>[root@localhost tmp]# /etc/init.d/mysql startStarting MySQL. SUCCESS! 
</code></pre>
<h2 id="8配置mysql到环境变量">8.配置mysql到环境变量</h2>
<pre><code>[root@localhost tmp]# vim /etc/profile
export MYSQL57_HOME=/usr/local/mysql57/bin #mysql5.7/bin路径export PATH=$PATH:${MYSQ57_HOME}
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdn.net/20180811154113533?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>这个地方是冒号 ( ：)</p>
<p>设置环境变量立即生效</p>
<pre><code>[root@localhost tmp]# source /etc/profile
</code></pre>
<h2 id="9mysql忘记密码">9.mysql忘记密码</h2>
<p>切换到mysql下的bin目录</p>
<pre><code>[root@localhost bin]# ./mysql -u root -pEnter password: ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)
</code></pre>
<p>ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)</p>
<p>密码错误。。而且之前安装的密码也忘记了</p>
<p>解决方案：</p>
<h3 id="第一步跳过mysql的密码认证过程">第一步：跳过MySQL的密码认证过程</h3>
<p>(注：windows下修改的是my.ini)</p>
<pre><code>[root@localhost bin]# #vim /etc/my.cnf
</code></pre>
<p>在[mysqld]后面任意一行添加“skip-grant-tables”用来跳过密码验证的过程，如下图所示：</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdn.net/20180811155411769?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>保存并退出(esc--&gt; :wq)</p>
<h3 id="第二步重启mysql">第二步：重启mysql</h3>
<pre><code>[root@localhost bin]# /etc/init.d/mysql restartShutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS!
</code></pre>
<h3 id="第三步登录mysql">第三步：登录mysql</h3>
<p>进入mysql/bin目录，启动mysql</p>
<pre><code>[root@localhost bin]# ./mysql
</code></pre>
<p>启动成功</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdn.net/20180811155702817?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<h3 id="第四步使用sql语句修改密码">第四步：使用sql语句修改密码</h3>
<pre><code class="language-sql">mysql&gt; use mysql;mysql&gt; update user set authentication_string=password(&quot;你的新密码&quot;) where user=&quot;root&quot;;mysql&gt; flush privileges;mysql&gt; quit
</code></pre>
<p>注意：mysql5.7没有password字段</p>
<pre><code>ERROR 1054 (42S22): Unknown column 'password' in 'field list'
</code></pre>
<h3 id="第五步重新编辑mycnf">第五步：重新编辑my.cnf</h3>
<p>去掉[mysqld]后面的“skip-grant-tables”</p>
<pre><code>[root@localhost bin]# vim /etc/my.cnf 
</code></pre>
<h3 id="第六步重启mysql">第六步：重启mysql</h3>
<pre><code>[root@localhost bin]# /etc/init.d/mysql restart
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdn.net/20180811161048595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<h2 id="10设置mysql远程登录">10.设置mysql远程登录</h2>
<p>先本地登录mysql</p>
<pre><code>[root@localhost bin]# ./mysql -uroot -pEnter password: Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.21 Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. 
</code></pre>
<h3 id="报错">报错</h3>
<p>突然报错</p>
<p>ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</p>
<pre><code>mysql&gt; use mysqlERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.
</code></pre>
<p>解决方案：需要重新修改一下密码</p>
<pre><code>mysql&gt; alter user 'root'@'localhost' identified by '修改的密码';mysql&gt; flush privileges;mysql&gt; quit;
</code></pre>
<h3 id="继续配置">继续配置</h3>
<pre><code>mysql&gt; use mysql;mysql&gt; update  user  set host='%' where user='root';mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypwd' WITH GRANT OPTION;mysql&gt; FLUSH PRIVILEGES; mysql&gt; quit;
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdn.net/20180811162227907?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<h3 id="重启mysql">重启mysql</h3>
<pre><code>[root@localhost bin]# service mysql restart;
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdn.net/20180811162257498?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<h3 id="设置防火墙">设置防火墙</h3>
<p>a)配置防火墙开启3306端口</p>
<pre><code>[root@localhost bin]# /sbin/iptables -I INPUT -p tcp --dport 3306-j ACCEPT[root@localhost bin]# /etc/rc.d/init.d/iptables saveiptables: Saving firewall rules to /etc/sysconfig/iptables:   [  OK  ][root@localhost bin]# /etc/rc.d/init.d/iptables restartiptables: Setting chains to policy ACCEPT: filter         	[  OK  ]iptables: Flushing firewall rules:                     	[  OK  ]iptables: Unloading modules:                       	[  OK  ]iptables: Applying firewall rules:                    	[  OK  ]
</code></pre>
<p>b)临时关闭防火墙</p>
<pre><code>[root@localhost bin]# service iptables stop
</code></pre>
<p>c)永久关闭防火墙</p>
<p>重启后永久生效</p>
<pre><code>[root@localhost bin]# chkconfig iptables off
</code></pre>
<h3 id="远程连接mysql">远程连接mysql</h3>
<p>连接成功</p>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdn.net/20180811162708303?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdn.net/20180811162738485?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Bkc3UxNjE1MzAyNDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" loading="lazy"></figure>
<p>参考博客：</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux]]></title>
        <id>https://newbe1.github.io/post/linux</id>
        <link href="https://newbe1.github.io/post/linux">
        </link>
        <updated>2020-01-12T10:49:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="linux">Linux</h1>
<h2 id="简单的脚本书写">简单的脚本书写</h2>
<pre><code class="language-vi">vi start.sh

编写脚本 保存退出

chmod +x start.sh   赋权使其可执行

./start.sh 执行脚本
</code></pre>
<h2 id="文件-权限">文件  权限</h2>
<pre><code class="language-chown">chown user:market f01　　//把文件f01的主改为uesr，添加到market组
chown -R liu /usr/meng  //将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu：
</code></pre>
<h2 id="防火墙基本操作">防火墙基本操作</h2>
<p><strong>1.firewalld的基本使用</strong></p>
<p>启动：  systemctl start firewalld</p>
<p>查状态：systemctl status firewalld</p>
<p>停止：  systemctl disable firewalld</p>
<p>禁用：  systemctl stop firewalld</p>
<p>在开机时启用一个服务：systemctl enable firewalld.service</p>
<p>在开机时禁用一个服务：systemctl disable firewalld.service</p>
<p>查看服务是否开机启动：systemctl is-enabled firewalld.service</p>
<p>查看已启动的服务列表：systemctl list-unit-files|grep enabled</p>
<p>查看启动失败的服务列表：systemctl --failed</p>
<p><strong>2.配置firewalld-cmd</strong></p>
<p>查看版本： firewall-cmd --version</p>
<p>查看帮助： firewall-cmd --help</p>
<p>显示状态： firewall-cmd --state</p>
<p>查看所有打开的端口： firewall-cmd --zone=public --list-ports</p>
<p>更新防火墙规则： firewall-cmd --reload</p>
<p>查看区域信息:  firewall-cmd --get-active-zones</p>
<p>查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0</p>
<p>拒绝所有包：firewall-cmd --panic-on</p>
<p>取消拒绝状态： firewall-cmd --panic-off</p>
<p>查看是否拒绝： firewall-cmd --query-panic</p>
<p><strong>3.添加端口</strong></p>
<p>添加端口80	firewall-cmd --add-port=80/tcp --permanent</p>
<p>查端口80是否开启	firewall-cmd --query-port=80/tcp</p>
<p>关闭80端口	 firewall-cmd --remove-port=80/tcp --permanent</p>
<p>重新载入更新防火墙规则	firewall-cmd --reload</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[摘抄]]></title>
        <id>https://newbe1.github.io/post/ma-ma</id>
        <link href="https://newbe1.github.io/post/ma-ma">
        </link>
        <updated>2020-01-12T09:48:41.000Z</updated>
        <content type="html"><![CDATA[<p>“从小觉得最厉害的人就是妈妈，不怕黑，什么都知道，做好吃的饭，把生活打理得井井有条，哭着不知道怎么办时只好找她。可我好像忘了这个被我依靠的人也曾是个小姑娘，怕黑也掉眼泪，笨手笨脚会被针扎到手。最美的姑娘，是什么让你变得这么强大呢，是岁月，还是爱。”——德卡先生的信箱</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[霸王别姬]]></title>
        <id>https://newbe1.github.io/post/hdfgh</id>
        <link href="https://newbe1.github.io/post/hdfgh">
        </link>
        <updated>2020-01-12T09:28:56.000Z</updated>
        <content type="html"><![CDATA[<p>他是假霸王,你是真虞姬</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础]]></title>
        <id>https://newbe1.github.io/post/wo-de-bo-ke</id>
        <link href="https://newbe1.github.io/post/wo-de-bo-ke">
        </link>
        <updated>2020-01-11T10:52:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java数据类型">Java数据类型</h1>
<h3 id="short"><strong>short</strong></h3>
<p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误</p>
<p>short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<h3 id="char"><strong>char</strong></h3>
<p>char是用来存储Unicode编码的字符的  Unicode中包含了汉字</p>
<p><strong>&lt;&lt;</strong></p>
<p>将一个数左移n位就是乘以2的n次方  &lt;&lt;位运算是cpu支持的 效率最高</p>
<h3 id="final"><strong>final</strong></h3>
<p>final修饰的类不能被继承</p>
<p>final修饰变量时 引用变量不能变 引用对象指向的对象中的内容是可变的</p>
<p><em>java.lang:</em></p>
<p>Boolean Short Integer Long Float String Double Byte void  (八大类型的包装类加一个void 都是被final修饰的)</p>
<p><em>java.util:</em></p>
<p>UUID Scanner</p>
<h3 id="string">string</h3>
<p>String 中对象是不可变的  线程安全</p>
<p>StringBuffer方法中加了同步锁 线程安全</p>
<p>StringBuilder 方法中没有同步锁  线程不安全</p>
<p>操作少量数据用String</p>
<p>单线程操作大量数据用StringBuilder</p>
<p>多线程操作大量数据用StringBuffer</p>
<h3 id="线程池的优势"><strong>线程池的优势</strong></h3>
<p>降低资源消耗   通过重复利用已创建的线程降低线程创建消耗的资源</p>
<p>提高响应速度 当任务到达时不需等待线程就可以立即执行</p>
<p>提高线程的可管理性  使用线程池统一分配管理和优化</p>
<h1 id="java网络">Java网络</h1>
<h3 id="osi七层模型"><strong>osi七层模型</strong></h3>
<p>物理层</p>
<p>数据链路层</p>
<p>网络层</p>
<p>传输层</p>
<p>会话层</p>
<p>表示层</p>
<p>应用层</p>
<h3 id="输入url显示主页的过程"><strong>输入url显示主页的过程</strong></h3>
<p>DNS解析</p>
<p>TCP连接</p>
<p>发送HTTP请求</p>
<p>服务器处理请求返回一个HTML</p>
<p>浏览器渲染页面</p>
<p>链接结束</p>
<h3 id="tcp三次握手"><strong>TCP三次握手</strong></h3>
<p>客户端发送带有SYN的数据包</p>
<p>服务端发送带有SYN/ACK的数据包</p>
<p>客户端发送带有ACK的数据包</p>
<p>建立可靠的通信信道  确认接受和发送都正常</p>
<p>SNY确认发送发到接受方的通信美问题 ACK确认接收方到发送方的通道美问题</p>
<h3 id="断开连接需四次挥手"><strong>断开连接需四次挥手</strong></h3>
<p>客户端发送一个FIN 关闭数据传送</p>
<p>服务端收到FIN发送一个ACK</p>
<p>服务端关闭连接 发送一个FIN给客户端</p>
<p>客户端发送一个ACK确认关闭</p>
<h1 id="反射">反射</h1>
<p><strong>定义</strong>:在运行状态下,对任意一个类,都能制度这个类的所有属性和方法;对于任意对象,都能调用它的方法和属性;这种动态获取信息和调用对象的方法叫做Java的反射机制.</p>
<h1 id="io流"><strong>IO流</strong></h1>
<p>![IO-操作方式分类](C:\Users\22215\Pictures\Saved Pictures\IO-操作方式分类.png)</p>
<hr>
<h1 id="多态">多态</h1>
<p>多态存在的三个必要条件</p>
<p>1.继承</p>
<p>2.重写</p>
<p>3.父类引用指向子类对象</p>
<p><strong>例子</strong></p>
<pre><code class="language-java">	public class duotai {
    public static void main(String[] args) {
        //Animal animal1 = new Animal()   抽象类无法直接实例化  只能通过实例化其子类 来初始化这个类

        Animal animal = new Cat();  //向上转型

        show(animal);
    }

    public static void show(Animal animal){
        animal.eat();  //能使用从父类中继承的方法  调用的是子类中的方法

        //类型判断
        if(animal instanceof Cat){
            Cat cat = (Cat) animal;   //向下转型
            cat.work();               //可以使用子类独有的work 方法了
        }else if(animal instanceof Dog){
            Dog dog = (Dog) animal;
            dog.work();
        }
    }
}

abstract class Animal{
    abstract void eat();
}

 class Cat extends Animal{    //继承Animal类 则必须实现Animal中的方法 可以进行重写 可以添加自己的独有方法
    public void eat(){
        System.out.println(&quot;吃鱼&quot;);
    }

    public void work() {
        System.out.println(&quot;抓老鼠&quot;);
    }
}

 class Dog extends Animal{
    public void eat(){
        System.out.println(&quot;吃骨头&quot;);
    }

    public void work() {
        System.out.println(&quot;看门&quot;);
    }
}

</code></pre>
<h1 id="杂的">杂的</h1>
<h3 id="和的区别"><strong>&amp;和&amp;&amp;的区别</strong></h3>
<p>都是逻辑与运算符 都可以表示与（and）</p>
<p>&amp;&amp;有短路效果 第一个表达式为false时就不会运行第二个表达式  例：对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;  所有&amp;&amp;的效率高点 好用点</p>
<h3 id="和equals"><strong>==和equals</strong></h3>
<p><mark>专门比较两个对象的地址是否相等 判断是否为同一个对象 (基本数据类型</mark>比较的是<br>
值，引用数据类型==比较的是内存地址)</p>
<p>equals  类没覆盖了equals()方法 则等价于 ==</p>
<p>覆盖了equals()方法（例如String）时 只要内容相同就相等</p>
<pre><code class="language-java">String a = new String(&quot;foo&quot;);   //a为一个引用  指向foo
String b = new String(&quot;foo&quot;);   //b为另一个引用 指向的对象内容为foo 但不是同一个对象  所有 a == b 为false  但内容相同 a.equals(b) 为true
String aa = &quot;boo&quot;;    //放在常量池中的
String bb = &quot;boo&quot;;    //在常量池中查找
</code></pre>
<p>Math.ceil(11.3)的结果为12  （向下取整）</p>
<p>Math.floor(11.6)的结果为11 （向上取整）</p>
<p>Math.round(-11.5)的结果为-11 （将原来的数 +0.5 再向下取整）</p>
<h3 id="抽象类和接口">抽象类和接口</h3>
<p>抽象类中可以有构造方法  接口中没有</p>
<p>抽象类中可以有成员变量  接口中没有</p>
<p>抽象类中有静态方法 接口中没有</p>
<p>一个类可以实现多个接口 但只能继承一个抽象类</p>
<p>接口可以多重实现  抽象类只能单继承</p>
<p>接口中的每个方法都是隐式抽象的，接口中的方法会被隐式指定为public abstract（只能是这样的 其他的会报错）不能含有静态方法或静态代码块</p>
<p>都可以被继承</p>
<p>都不能被实例化</p>
<p>都可以包含方法申明</p>
<h3 id="加密算法">加密算法</h3>
<p><code>AES</code>、<code>DES</code>、<code>3DES</code> 都是 <strong>对称</strong> 的 <strong>块加密算法</strong>，<strong>加解密</strong> 的过程是 <strong>可逆的</strong></p>
<p><code>MD5</code> 用的是 <strong>哈希函数</strong>，它的典型应用是对一段信息产生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。严格来说，<code>MD5</code> 不是一种 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。无论是多长的输入，<code>MD5</code> 都会输出长度为 <code>128bits</code> 的一个串 (通常用 <code>16</code> <strong>进制</strong> 表示为 <code>32</code> 个字符)。</p>
<p><code>RSA</code> 加密算法是目前最有影响力的 <strong>公钥加密算法</strong>，并且被普遍认为是目前 <strong>最优秀的公钥方案</strong> 之一。<code>RSA</code> 是第一个能同时用于 <strong>加密</strong> 和 <strong>数字签名</strong> 的算法，它能够 <strong>抵抗</strong> 到目前为止已知的 <strong>所有密码攻击</strong>，已被 <code>ISO</code> 推荐为公钥数据加密标准。</p>
<h3 id="java中的内存溢出的集中情况outofmemoryerror">Java中的内存溢出的集中情况OutOfMemoryError</h3>
<p><strong>PermGen space</strong></p>
<p>Java虚拟机装载类的空间不够，通过设置初始永久保存区域和最大永久保存区域的大小解决</p>
<p><strong>Java heap space</strong></p>
<p>Java虚拟机创建的对象太多，进行垃圾回收时，虚拟机分配的堆内存空间已满，可通过增加Java虚拟机中的初始堆大小和最大堆大小来解决</p>
<p><strong>unable to create new native thread</strong></p>
<p>创建过多线程会发生这种情况，控制线程的数量</p>
<h3 id="lambda表达式">lambda表达式</h3>
<p>lambda编程是建立在函数式接口得基础上的</p>
<ol>
<li>
<p>只包含一个抽象方法的接口，称为函数式接口。</p>
</li>
<li>
<p>可以通过 Lambda 表达式来创建该接口的对象。</p>
</li>
<li>
<p>可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>
</li>
</ol>
<p>在实际开发者两个比较常见的函数式接口：<strong>Runnable接口，Comparator接口</strong></p>
<p><em><strong>函数式接口的实例可以通过 lambda 表达式、 方法引用、构造方法引用来创建</strong></em></p>
<pre><code class="language-java">public class TestArray {
    
    public static void main(String[] args) {
        String[] players = {&quot;zhansgan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;zhaoliu&quot;,  &quot;wangmazi&quot;};  

        // 1.1 使用匿名内部类根据 surname 排序 players  
        Arrays.sort(players, new Comparator&lt;String&gt;() {  
            @Override  
            public int compare(String s1, String s2) {  
                return (s1.compareTo(s2));  
            }  
        });  
        
        // 1.2 使用 lambda 排序,根据 surname  
        Arrays.sort(players, (String s1, String s2) -&gt;  s1.compareTo(s2));  
         
//================================================================================================
          
        // 2.1 使用匿名内部类根据 name lenght 排序 players  
        Arrays.sort(players, new Comparator&lt;String&gt;() {  
            @Override  
            public int compare(String s1, String s2) {  
                return (s1.length() - s2.length());  
            }  
        });  

        // 2.2使用Lambda,根据name length  
        Arrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));  
    
//==================================================================================================    
        
        // 3.1 使用匿名内部类排序 players, 根据最后一个字母  
        Arrays.sort(players, new Comparator&lt;String&gt;() {  
            @Override  
            public int compare(String s1, String s2) {  
                return (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));  
            }  
        });  

        // 3.2 使用Lambda,根据最后一个字母
        Arrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1)));  
    }
}
</code></pre>
<h3 id="传参和接收参数">传参和接收参数</h3>
<p>@ResquestBody主要是用来接受json字符串中的数据的 GET方法没有请求体,所有使用@ResquestBody接受数据的时候,前端不能用GET进行提交而是使用POST进行提交.在后端的接受方法中@ResquestBody和@ResquestParam可以同时使用,但一个请求中@ResquestBody只能有一个,@ResquestParam可以有多个.</p>
<p><u>注</u></p>
<pre><code class="language-java">*  如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。 
* 如果参数是放在请求体中传入后台,则需要用@ResquestBody进行接受;如果不是放在请求体中的那么就需要用@ResquestParam进行接受,或者两者都不用进行接受
*  如果参数前不写@RequestParam(xxx)的话，那么前端可以没有对应的xxx名字才行，如果有xxx的话，那么就会自动匹配；没有的话，请求也能正确发送。 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx]]></title>
        <id>https://newbe1.github.io/post/gu-dian-feng-ge</id>
        <link href="https://newbe1.github.io/post/gu-dian-feng-ge">
        </link>
        <updated>2020-01-11T09:08:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-安装nginx">一、安装Nginx</h1>
<h2 id="1-准备工作"><strong>1、准备工作</strong></h2>
<p>（1）打开虚拟机，使用远程连接工具连接 linux 操作系统</p>
<p>（2）到 nginx 官网下载软件</p>
<p>http://nginx.org/</p>
<h2 id="2-开始进行-nginx-安装">2、开始进行 nginx 安装</h2>
<h3 id="1安装-pcre-依赖"><strong>（1）安装 pcre 依赖</strong></h3>
<ol>
<li>联网下载 pcre 压缩文件依赖</li>
</ol>
<pre><code>wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz
</code></pre>
<ol start="2">
<li>解压压缩文件</li>
</ol>
<p>使用命令 tar –xvf pcre-8.37.tar.gz</p>
<ol start="3">
<li>./configure 完成后，回到 pcre 目录下执行 make，最后执行 make install</li>
</ol>
<p>查看pcre依赖是否安装成功：pcre-config --version</p>
<h3 id="2安装-openssl-zlib-gcc-依赖"><strong>（2）安装 openssl 、zlib 、 gcc 依赖</strong></h3>
<pre><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel
</code></pre>
<h3 id="3安装-nginx"><strong>（3）安装 nginx</strong></h3>
<p>* 使用命令解压</p>
<p>* ./configure</p>
<p>* make &amp;&amp; make install</p>
<p>进入目录 /usr/local/nginx/sbin/nginx 启动服务</p>
<p><strong>安装后，不能访问的，需要对防火墙进行设置</strong></p>
<p><strong>也可以直接关闭防火墙，并防止自启(在练习模式中)</strong></p>
<pre><code>//关闭防火墙&amp;&amp;防火墙自启

systemctl stop firewalld &amp;&amp; systemctl disable firewalld

//安装Iptables管理工具&amp;&amp;启动Iptables&amp;&amp;设为Iptables开机自启&amp;&amp;清空Iptables规则&amp;&amp;保存Iptables默认规则

yum -y install iptables-services &amp;&amp; systemctl start iptables &amp;&amp; systemctl enable iptables&amp;&amp; iptables -F &amp;&amp; service iptables save
</code></pre>
<p>查看开放的端口</p>
<p>firewall-cmd --list-all</p>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102553820-1653097356.png" alt="img" loading="lazy"></figure>
<p>设置开放的端口号</p>
<p>firewall-cmd --add-service=http –permanent</p>
<p>firewall-cmd --add-port=80/tcp --permanent</p>
<p>设置之后需要重启防火墙</p>
<p>firewall-cmd --reload</p>
<figure data-type="image" tabindex="2"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102610520-1568314025.png" alt="img" loading="lazy"></figure>
<p>访问成功</p>
<figure data-type="image" tabindex="3"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102622854-1627774877.png" alt="img" loading="lazy"></figure>
<h1 id="二-nginx常用命令"><strong>二、Nginx常用命令</strong></h1>
<p>进入 nginx 目录中: cd /usr/local/nginx/sbin</p>
<ol>
<li>查看 nginx 版本号</li>
</ol>
<p>./nginx -v</p>
<ol start="2">
<li>启动 nginx</li>
</ol>
<p>./nginx</p>
<p>查看是否启动成功：ps -ef|grep nginx</p>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102726015-172811692.png" alt="img" loading="lazy"></figure>
<ol start="3">
<li>停止 nginx</li>
</ol>
<p>./nginx -s stop</p>
<ol start="4">
<li>重新加载 nginx</li>
</ol>
<p>./nginx -s reload</p>
<h1 id="三-nginxconf配置文件"><strong>三、nginx.conf配置文件</strong></h1>
<h2 id="位置"><strong>位置</strong></h2>
<p>vim /usr/local/nginx/conf/nginx.conf</p>
<h2 id="配置文件中的内容包含三部分">配置文件中的内容（包含三部分)</h2>
<h3 id="全局块配置服务器整体运行的配置指令">全局块：配置服务器整体运行的配置指令</h3>
<p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配</p>
<p>置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以</p>
<p>及配置文件的引入等。</p>
<p>比如上面第一行配置的：</p>
<p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是</p>
<p>会受到硬件、软件等设备的制约</p>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102802614-510328292.png" alt="img" loading="lazy"></figure>
<h3 id="events-块影响-nginx-服务器与用户的网络连接">events 块：影响 Nginx 服务器与用户的网络连接</h3>
<p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process</p>
<p>下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word</p>
<p>process 可以同时支持的最大连接数等。</p>
<p>上述例子就表示每个 work process 支持的最大连接数为 1024.</p>
<p>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102827884-232471630.png" alt="img" loading="lazy"></figure>
<h3 id="http-块">http 块</h3>
<p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<p>需要注意的是：http 块也可以包括 http 全局块、server 块。</p>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102837788-914776640.png" alt="img" loading="lazy"></figure>
<h4 id="1-http-全局块">1. http 全局块</h4>
<p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102851922-1592334025.png" alt="img" loading="lazy"></figure>
<h4 id="2-server-块">2. server 块</h4>
<p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了</p>
<p>节省互联网服务器硬件成本。</p>
<p>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</p>
<p>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>
<figure data-type="image" tabindex="9"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029102901346-2016909563.png" alt="img" loading="lazy"></figure>
<h5 id="1全局-server-块">1.全局 server 块</h5>
<p>最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p>
<h5 id="2-location-块">2. location 块</h5>
<p>一个 server 块可以配置多个 location 块。</p>
<p>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称</p>
<p>（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓</p>
<p>存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
<h1 id="四-nginx-反向代理实例">四、Nginx 反向代理实例</h1>
<h2 id="实现效果"><strong>实现效果</strong></h2>
<p>打开浏览器，在浏览器地址栏输入地址 www.123.com，跳转到 liunx 系统 tomcat 主页</p>
<p>面中</p>
<h2 id="准备工作"><strong>准备工作</strong></h2>
<p><strong>在 liunx 系统安装 tomcat，使用默认端口 8080</strong></p>
<ul>
<li>
<p>tomcat 安装文件放到 liunx 系统中，解压</p>
</li>
<li>
<p>进入 tomcat 的 bin 目录中，./startup.sh 启动 tomcat 服务器</p>
</li>
</ul>
<p><strong>对外开放访问的端口</strong></p>
<p>firewall-cmd --add-port=8080/tcp --permanent</p>
<p>firewall-cmd –reload</p>
<p><strong>查看已经开放的端口号</strong></p>
<p>firewall-cmd --list-all</p>
<h2 id="访问过程的分析"><strong>访问过程的分析</strong></h2>
<figure data-type="image" tabindex="10"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103129000-1647870419.png" alt="img" loading="lazy"></figure>
<h2 id="具体配置"><strong>具体配置</strong></h2>
<p>第一步 在 windows 系统的 host 文件进行域名和 ip 对应关系的配置</p>
<figure data-type="image" tabindex="11"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103141392-957260709.png" alt="img" loading="lazy"></figure>
<p>添加内容在 host 文件中</p>
<figure data-type="image" tabindex="12"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103147529-141884990.png" alt="img" loading="lazy"></figure>
<p>第二步 在 nginx 进行请求转发的配置（反向代理配置）</p>
<figure data-type="image" tabindex="13"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103200326-1880157403.png" alt="img" loading="lazy"></figure>
<h2 id="最终测试"><strong>最终测试</strong></h2>
<figure data-type="image" tabindex="14"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103210478-1402408403.png" alt="img" loading="lazy"></figure>
<h1 id="五-nginx-反向代理实例">**五、Nginx 反向代理实例 **</h1>
<h2 id="实现效果-2"><strong>实现效果</strong></h2>
<p>使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中</p>
<p>nginx 监听端口为 9001，</p>
<p>访问 http://192.168.17.129:9001/edu/ 直接跳转到 127.0.0.1:8080</p>
<p>访问 http:// 192.168.17.129:9001/vod/ 直接跳转到 127.0.0.1:8081</p>
<h2 id="准备工作-2"><strong>准备工作</strong></h2>
<p>（1）准备两个 tomcat 服务器，一个 8080 端口，一个 8081 端口</p>
<p>（2）创建文件夹和测试页面</p>
<h2 id="具体配置-2">具体配置</h2>
<p>（1）找到 nginx 配置文件，进行反向代理配置</p>
<figure data-type="image" tabindex="15"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103236151-575997990.png" alt="img" loading="lazy"></figure>
<p>（2）开放对外访问的端口号 9001 8080 8081</p>
<h2 id="最终测试-2"><strong>最终测试</strong></h2>
<figure data-type="image" tabindex="16"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103245851-2135151223.png" alt="img" loading="lazy"></figure>
<h1 id="六-nginx-配置实例-负载均衡"><strong>六、Nginx 配置实例-负载均衡</strong></h1>
<h2 id="实现效果-3"><strong>实现效果</strong></h2>
<p>（1）浏览器地址栏输入地址 http://192.168.17.129/edu/a.html，负载均衡效果，平均 8080</p>
<p>和 8081 端口中</p>
<h2 id="准备工作-3"><strong>准备工作</strong></h2>
<p>（1）准备两台 tomcat 服务器，一台 8080，一台 8081</p>
<p>（2）在两台 tomcat 里面 webapps 目录中，创建名称是 edu 文件夹，在 edu 文件夹中创建</p>
<p>页面 a.html，用于测试</p>
<h2 id="在-nginx-的配置文件中进行负载均衡的配置"><strong>在 nginx 的配置文件中进行负载均衡的配置</strong></h2>
<figure data-type="image" tabindex="17"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103257021-406101154.png" alt="img" loading="lazy"></figure>
<h2 id="nginx-分配服务器四种策略"><strong>nginx 分配服务器四种策略</strong></h2>
<h3 id="1-轮询默认"><strong>1. 轮询（默认）</strong></h3>
<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。</p>
<h3 id="2-weight"><strong>2. weight</strong></h3>
<p>weight 代表权重默认为 1,权重越高被分配的客户端越多</p>
<figure data-type="image" tabindex="18"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103434709-133983538.png" alt="img" loading="lazy"></figure>
<h3 id="3-ip_hash"><strong>3. ip_hash</strong></h3>
<p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>
<figure data-type="image" tabindex="19"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103440910-1253898902.png" alt="img" loading="lazy"></figure>
<h3 id="4-fair第三方"><strong>4. fair（第三方）</strong></h3>
<p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>
<figure data-type="image" tabindex="20"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103448391-1932086344.png" alt="img" loading="lazy"></figure>
<h1 id="七-nginx-配置实例-动静分离"><strong>七、Nginx 配置实例-动静分离</strong></h1>
<h2 id="什么是动静分离"><strong>什么是动静分离</strong></h2>
<figure data-type="image" tabindex="21"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103503613-506507153.png" alt="img" loading="lazy"></figure>
<p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和</p>
<p>静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx</p>
<p>处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种，</p>
<p>一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</p>
<p>另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。</p>
<p>通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏</p>
<p>览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源</p>
<p>设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，</p>
<p>所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，</p>
<p>不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一</p>
<p>个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码 304，</p>
<p>如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<h2 id="准备工作-4"><strong>准备工作</strong></h2>
<p>在 liunx 系统中准备静态资源，用于进行访问</p>
<figure data-type="image" tabindex="22"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103551408-155195568.png" alt="img" loading="lazy"></figure>
<h2 id="具体配置-3"><strong>具体配置</strong></h2>
<p>在 nginx 配置文件中进行配置</p>
<figure data-type="image" tabindex="23"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103601180-712857275.png" alt="img" loading="lazy"></figure>
<h2 id="最终测试-3"><strong>最终测试</strong></h2>
<p>（1）浏览器中输入地址</p>
<p>http://192.168.17.129/image/01.jpg</p>
<figure data-type="image" tabindex="24"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103613911-2017185401.png" alt="img" loading="lazy"></figure>
<p>因为配置文件 autoindex on</p>
<figure data-type="image" tabindex="25"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103620555-1775332206.png" alt="img" loading="lazy"></figure>
<p>重点是添加 location，</p>
<p>最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat</p>
<p>服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回</p>
<p>了，不走后端 tomcat 服务器</p>
<h1 id="八-nginx原理"><strong>八、nginx原理</strong></h1>
<h2 id="mater-和-worker">mater 和 worker</h2>
<figure data-type="image" tabindex="26"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103710873-640599395.png" alt="img" loading="lazy"></figure>
<figure data-type="image" tabindex="27"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103717881-58535625.png" alt="img" loading="lazy"></figure>
<h2 id="worker-如何进行工作的">worker 如何进行工作的</h2>
<figure data-type="image" tabindex="28"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103730680-1429030716.png" alt="img" loading="lazy"></figure>
<h2 id="一个-master-和多个-woker-有好处">一个 master 和多个 woker 有好处</h2>
<p>（1）可以使用 nginx –s reload 热部署，利用 nginx 进行热部署操作</p>
<p>（2）每个 woker 是独立的进程，如果有其中的一个 woker 出现问题，其他 woker 独立的，</p>
<p>继续进行争抢，实现请求过程，不会造成服务中断</p>
<h2 id="设置多少个-woker-合适">设置多少个 woker 合适</h2>
<p>worker 数和服务器的 cpu 数相等是最为适宜的</p>
<h2 id="连接数-worker_connection">连接数 worker_connection</h2>
<ol>
<li>：发送请求，占用了 woker 的几个连接数？</li>
</ol>
<p>答案：2 或者 4 个</p>
<figure data-type="image" tabindex="29"><img src="https://img2018.cnblogs.com/blog/1455597/201910/1455597-20191029103745507-149451607.png" alt="img" loading="lazy"></figure>
<ol start="2">
<li>：nginx 有一个 master，有四个 woker，每个 woker 支持最大的连接数 1024，支持的</li>
</ol>
<p>最大并发数是多少？</p>
<ul>
<li>
<p>普通的静态访问最大并发数是： worker_connections * worker_processes /2，</p>
</li>
<li>
<p>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是 worker_connections *</p>
</li>
</ul>
<p>worker_processes/4。</p>
<h1 id="九-nginx配置高可用">九、Nginx配置高可用</h1>
<h2 id="原理展示">原理展示</h2>
<p>![](C:\Users\22215\Pictures\Saved Pictures\高可用.png)</p>
<p>使用keepalived实现高可用,两台nginx(主备两台)安装此软件,绑定同一个虚拟IP用户通过这个虚拟IP进行访问nginx.其中一台挂了,则虚拟IP指向另外一台,请求不会受影响.</p>
<h2 id="准备工作-5">准备工作</h2>
<p>服务器两台,同时安装ngixn和keepalived</p>
<p><strong>1. 安装keepalived</strong></p>
<p>yum -y install keepalived</p>
<p><strong>2. firewall-cmd --list-all</strong></p>
<p>vi /etc/keepalived/keepalived.conf</p>
<pre><code class="language-bash">global_defs {
#   notification_email {
#     acassen@firewall.loc
#     failover@firewall.loc
#     sysadmin@firewall.loc
#   }
#   notification_email_from Alexandre.Cassen@firewall.loc
#   smtp_server 192.168.200.1
#   smtp_connect_timeout 30
   router_id dreamer1     #定义路由器标识信息，相同的局域网唯一，标识本节点的字条串,通常为hostname
#   vrrp_skip_check_adv_addr
#   vrrp_strict
#   vrrp_garp_interval 0
#   vrrp_gna_interval 0
}
vrrp_script chk_nginx {
        script &quot;/etc/keepalived/nginx_check.sh&quot; ## 检测 nginx 状态的脚本路径
        interval 2 ## 检测时间间隔
        weight -20 ## 如果条件成立，权重-20
}

# 虚拟 IP 配置 vrrp
vrrp_instance VI_1 {
    state MASTER   # 状态参数 MASTER/BACKUP 仅表示说明，主节点为 MASTER， 对应的备份节点为 BACKUP 
    interface ens33 # 绑定虚拟 IP 的网络接口，与本机 IP 地址所在的网络接口相同，ifconfig查看
    virtual_router_id 51 #虚拟路由的 ID 号， 两个节点设置必须一样， 可选 IP 最后一段使用, 相同的 VRID 为一个组，他将决定多播的 MAC 地址
   
    priority 100  # 优先级决定是主还是备 --&gt; 越大越优先，节点优先级， 值范围 0-254， MASTER 要比 BACKUP 高
    advert_int 1  # 主备心跳通讯时间间隔，组播信息发送间隔，两个节点设置必须一样， 默认 1s
    authentication {  # 认证授权，设置验证信息，两个节点必须一致 
        auth_type PASS
        auth_pass 1111
    }
        track_script {
                chk_nginx ## 执行 Nginx 监控的服务
        }
    virtual_ipaddress {  #设备之间使用的虚拟ip地址，可以定义多个
        192.168.136.99
        #192.168.200.17
        #192.168.200.18
    }
}

</code></pre>
<p><strong>3. 编辑心跳脚本(监测nginx的状态 keepalived读取此脚本</strong></p>
<p>touch /etc/keepalived/nginx_check.sh</p>
<pre><code class="language-bash">#!/bin/bash
counter=$(ps -C nginx --no-heading|wc -l)
if [ &quot;${counter}&quot; = &quot;0&quot; ]; then
    /usr/sbin/nginx
    sleep 2
    counter=$(ps -C nginx --no-heading|wc -l)
    if [ &quot;${counter}&quot; = &quot;0&quot; ]; then
        /etc/init.d/keepalived stop
    fi
fi
</code></pre>
<p><strong>4. 启动keepalived</strong></p>
<p>systemctl start keepalived</p>
<p><strong>5. 完成</strong></p>
<p>此时就可以达到高可用的效果了</p>
<h2 id="九-tomcat和nginx">九、Tomcat和Nginx</h2>
<ul>
<li>
<p>Nginx在均衡负载里属于前端服务器，用来处理请求的转发（反向代理）；属于静态页面服务器，大部分时间不会运行项目。</p>
</li>
<li>
<p>Tomcat是后端服务器，属于Java servlet容器，用来生成动态页面，直接运行项目。（发送一个请求，先经过Nginx，它会合理地将请求分配到后台比较不忙的Tomcat，Tomcat 处理好请求会将数据返回给Nginx，然后Nginx将数据返回给浏览器进行显示，如果是一些静态数据，Nginx会直接处理）</p>
</li>
<li>
<p>Tomcat/Jetty 等都是Web 容器，负责管理整个Servlet的生命周期。类似Spring 的IOC会管理整个Bean的生命周期。 而GlassFish/Weblogic这一类的 application Server，则会管理更多，包含命名服务器，EJB等资源。</p>
</li>
<li>
<p>Nginx/apache 可以说是web server ，它们可以处理静态资源，无法处理servlet，一般把Nginx放在前端处理静态资源，如果有对应的Servlet请求，则通过AJP转给后端服务器处理</p>
</li>
<li>
<p>“tomcat用在java后台程序上，java后台程序难道不能用apache和nginx吗？”不能。apache和nginx不是servlet容器。什么是servlet容器呢？即实现HttpServletRequest、HttpServletResponse、HttpSession等等接口，解析http请求，通过类加载器加载对应的servlet实现类并调用。也就是说servlet容器必须由java或者基于jvm的语言实现。</p>
</li>
</ul>
]]></content>
    </entry>
</feed>