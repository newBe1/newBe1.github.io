<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://newbe1.github.io/</id>
    <title></title>
    <updated>2020-01-11T11:07:23.180Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://newbe1.github.io/"/>
    <link rel="self" href="https://newbe1.github.io/atom.xml"/>
    <logo>https://newbe1.github.io/images/avatar.png</logo>
    <icon>https://newbe1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, </rights>
    <entry>
        <title type="html"><![CDATA[我的博客]]></title>
        <id>https://newbe1.github.io/post/wo-de-bo-ke</id>
        <link href="https://newbe1.github.io/post/wo-de-bo-ke">
        </link>
        <updated>2020-01-11T10:52:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="java数据类型">Java数据类型</h2>
<h3 id="short"><strong>short</strong></h3>
<p>对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误</p>
<p>short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。</p>
<h3 id="char"><strong>char</strong></h3>
<p>char是用来存储Unicode编码的字符的  Unicode中包含了汉字</p>
<p><strong>&lt;&lt;</strong></p>
<p>将一个数左移n位就是乘以2的n次方  &lt;&lt;位运算是cpu支持的 效率最高</p>
<h3 id="final"><strong>final</strong></h3>
<p>final修饰的类不能被继承</p>
<p>final修饰变量时 引用变量不能变 引用对象指向的对象中的内容是可变的</p>
<p><em>java.lang:</em></p>
<p>Boolean Short Integer Long Float String Double Byte void  (八大类型的包装类加一个void 都是被final修饰的)</p>
<p><em>java.util:</em></p>
<p>UUID Scanner</p>
<h3 id="string">string</h3>
<p>String 中对象是不可变的  线程安全</p>
<p>StringBuffer方法中加了同步锁 线程安全</p>
<p>StringBuilder 方法中没有同步锁  线程不安全</p>
<p>操作少量数据用String</p>
<p>单线程操作大量数据用StringBuilder</p>
<p>多线程操作大量数据用StringBuffer</p>
<h2 id="集合">集合</h2>
<p>ArrayList和LinkedList 不是同步的  线程不安全</p>
<p>ArrayList底层使用数组 LinkedList底层是双向链表</p>
<p>ArrayList的增删受时间复杂度影响 LinkedList则不受（不支持高效的随机元素访问）</p>
<h3 id="hashtable">HashTable</h3>
<p>HashTable底层是数组和链表结合在一起实现的，key和value都不能为null（空指针异常），线程安全（修改数据时锁住整个HashTable）效率低，ConcurrentHashMap做了相关优化</p>
<h3 id="hashmap">HashMap</h3>
<p>底层是数组和链表实现的，key和value都可以为null，线程不安全</p>
<h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<p>底层采用数组和链表实现，线程安全，key和value不能为null（空指针异常）</p>
<h3 id="线程池的优势"><strong>线程池的优势</strong></h3>
<p>降低资源消耗   通过重复利用已创建的线程降低线程创建消耗的资源</p>
<p>提高响应速度 当任务到达时不需等待线程就可以立即执行</p>
<p>提高线程的可管理性  使用线程池统一分配管理和优化</p>
<h2 id="java网络">Java网络</h2>
<h3 id="osi七层模型"><strong>osi七层模型</strong></h3>
<p>物理层</p>
<p>数据链路层</p>
<p>网络层</p>
<p>传输层</p>
<p>会话层</p>
<p>表示层</p>
<p>应用层</p>
<h3 id="输入url显示主页的过程"><strong>输入url显示主页的过程</strong></h3>
<p>DNS解析</p>
<p>TCP连接</p>
<p>发送HTTP请求</p>
<p>服务器处理请求返回一个HTML</p>
<p>浏览器渲染页面</p>
<p>链接结束</p>
<h3 id="tcp三次握手"><strong>TCP三次握手</strong></h3>
<p>客户端发送带有SYN的数据包</p>
<p>服务端发送带有SYN/ACK的数据包</p>
<p>客户端发送带有ACK的数据包</p>
<p>建立可靠的通信信道  确认接受和发送都正常</p>
<p>SNY确认发送发到接受方的通信美问题 ACK确认接收方到发送方的通道美问题</p>
<h3 id="断开连接需四次挥手"><strong>断开连接需四次挥手</strong></h3>
<p>客户端发送一个FIN 关闭数据传送</p>
<p>服务端收到FIN发送一个ACK</p>
<p>服务端关闭连接 发送一个FIN给客户端</p>
<p>客户端发送一个ACK确认关闭</p>
<h2 id="服务器相关">服务器相关</h2>
<h3 id="tomcat和nginx">Tomcat和Nginx</h3>
<p>Nginx在均衡负载里属于前端服务器，用来处理请求的转发（反向代理）；属于静态页面服务器，大部分时间不会运行项目。</p>
<p>Tomcat是后端服务器，属于Java servlet容器，用来生成动态页面，直接运行项目。（发送一个请求，先经过Nginx，它会合理地将请求分配到后台比较不忙的Tomcat，Tomcat 处理好请求会将数据返回给Nginx，然后Nginx将数据返回给浏览器进行显示，如果是一些静态数据，Nginx会直接处理）</p>
<p>Tomcat/Jetty 等都是Web 容器，负责管理整个Servlet的生命周期。类似Spring 的IOC会管理整个Bean的生命周期。 而GlassFish/Weblogic这一类的 application Server，则会管理更多，包含命名服务器，EJB等资源。</p>
<p>Nginx/apache 可以说是web server ，它们可以处理静态资源，无法处理servlet，一般把Nginx放在前端处理静态资源，如果有对应的Servlet请求，则通过AJP转给后端服务器处理</p>
<p>“tomcat用在java后台程序上，java后台程序难道不能用apache和nginx吗？”不能。apache和nginx不是servlet容器。什么是servlet容器呢？即实现HttpServletRequest、HttpServletResponse、HttpSession等等接口，解析http请求，通过类加载器加载对应的servlet实现类并调用。也就是说servlet容器必须由java或者基于jvm的语言实现。</p>
<h2 id="数据库">数据库</h2>
<h3 id="数据库性能优化"><strong>数据库性能优化</strong></h3>
<p><em>sql优化</em>：</p>
<p>​			少使用select*；</p>
<p>​			只查询一条记录时使用 limit 1；</p>
<p>​			使用连接查询代替子查询；</p>
<p>​			尽量使用一些能通过索引查询的关键字；</p>
<p><em>表结构优化</em>：</p>
<p>​			尽量使用数字类型的字段，提高比对效率；</p>
<p>​			长度不变且对查询速度要求高的数据可以考虑使用 char，否则使用 varchar；</p>
<p>​			表中字段过多时可以适当的进行垂直分割，将部分字段移动到另外一张表；</p>
<p>​			表中数据量过大可以适当的进行水平分割，将部分数据移动到另外一张表。</p>
<p><em>其他优化</em>：</p>
<p>​			 对查询效率高的字段适当建立索引提高效率；</p>
<p>​			根据表的用途使用合适的数据库引擎，读写分离；</p>
<h3 id="索引"><strong>索引</strong></h3>
<p><u>like以%开头会导致索引失效而进行全局扫描</u></p>
<p>mysql查询的方式 即访问类型有</p>
<p>ALL：全表扫描</p>
<p>index：索引全扫描</p>
<p>range：索引范围扫描</p>
<p>ref：使用非唯一索引扫描</p>
<p>eq_ref：使用唯一索引扫描</p>
<p>const，system：单表中 最多只有一个匹配行</p>
<p>（性能越来越好）</p>
<p><strong>作用</strong></p>
<p>快速访问表中的特定信息，提高查询速度</p>
<p>创建唯一索引，确保数据的唯一性</p>
<p>加速表和表之间的联系</p>
<p>减少查询中分组和排序的时间</p>
<p><strong>分类</strong></p>
<p>主键索引（PRIMAY KEY）</p>
<p>唯一索引（UNIQUE）</p>
<p>常规索引（INDEX）</p>
<p>全文索引（FULLTEXT）</p>
<p><strong>负面影响</strong></p>
<p>创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加，同时索引也需要占用物理空间，当对表进行操作的时候索引也要进行动态维护，会降低数据的维护速度</p>
<p><strong>创建索引的原则</strong></p>
<p>在频繁使用，用以缩小查询范围的字段或者用以排序的字段上建立索引</p>
<p>对应很少涉及查询的列或重复值较多的列，不宜创建索引</p>
<p>对于特殊的数据类型的列，不宜创建索引如（text）</p>
<h3 id="mysql的事务隔离级别"><strong>MySql的事务隔离级别</strong></h3>
<p><strong>Read uncommitted</strong>  ：读未提交  <u><strong>脏读</strong></u> 一个事务可以读取另一个未提交的事务的数据  可用读提交解决</p>
<p><strong>Read committed</strong> ：读提交  一个事务要等另一个事务提交后才能读取数据，但会出现一个事务范围内两个相同的查询出现不同的结果 这就是 <u><strong>不可重复读</strong></u> ，可用重复读解决这个问题</p>
<p><strong>Repeatable read</strong> ：重复读 在开始读取数据时（事务开启时） ， 不容许修改操作，可能出现<strong>幻读</strong> 当用户读取某一范围的数据行时，另一个事务又在该范围插入了新数据，用户再读取该范围的数据时会出现幻影行 <strong>Mysql的默认事务隔离级别</strong></p>
<p><strong>Serializable</strong> ：串行化 序列化 一个事务一个事务地执行，<strong>会导致大量超时现象和锁竞争</strong></p>
<p><u>不可重复读主要侧重于修改，幻读主要侧重于增删。解决不可重复读锁住满足条件的行，解决幻读需锁表</u></p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交（read uncommitted）</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读提交（read committed）</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>重复度（repeatable read）</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<h3 id="mysql锁概述">MySql锁概述</h3>
<p>**表级锁：**开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>
**行级锁：**开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。<br>
**页面锁：**开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<p>不同的存储引擎支持不同的锁机制</p>
<p>MyISAM和MEMORY采用表级锁</p>
<p>BDB存储引擎采用的是页面锁（page-level locking），但也支持表级锁</p>
<p>InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁</p>
<h3 id="五大约束">五大约束</h3>
<p>1.—-主键约束（Primay Key Coustraint） 唯一性，非空性</p>
<p>2.—-唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个</p>
<p>3.—-检查约束 (Check Counstraint) 对该列数据的范围、格式的限制（如：年龄、性别等）</p>
<p>4.—-默认约束 (Default Counstraint) 该数据的默认值</p>
<p>5.—-外键约束 (Foreign Key Counstraint) 需要建立两表间的关系并引用主表的列</p>
<p><em><strong>示例</strong></em></p>
<p>五大约束的语法示例</p>
<p>1.—-添加主键约束（将stuNo作为主键）</p>
<p>alter table stuInfo</p>
<p>add constraint PK_stuNo primary key (stuNo)</p>
<p>2.—-添加唯一约束（身份证号唯一，因为每个人的都不一样）</p>
<p>alter table stuInfo</p>
<p>add constraint UQ_stuID unique(stuID)</p>
<p>3.—-添加默认约束（如果地址不填 默认为“地址不详”）</p>
<p>alter table stuInfo</p>
<p>add constraint DF_stuAddress default (‘地址不详’) for stuAddress</p>
<p>4.—-添加检查约束 （对年龄加以限定 15-40岁之间）</p>
<p>alter table stuInfo</p>
<p>add constraint CK_stuAge check (stuAge between 15 and 40)</p>
<p>alter table stuInfo</p>
<p>add constraint CK_stuSex check (stuSex=’男’ or stuSex=’女′)</p>
<p>5.—-添加外键约束 (主表stuInfo和从表stuMarks建立关系，关联字段stuNo)</p>
<p>alter table stuInfo</p>
<p>add constraint FK_stuNo foreign key(stuNo)references stuinfo(stuNo)</p>
<h2 id="spring">spring</h2>
<h3 id="springbootapplication"><strong>@SpringBootApplication</strong></h3>
<p>@SpringBootConfiguration:等同于spring 的xml配置文件</p>
<p>@EnadleAutoConfiguration: 自动配置</p>
<p>@ComponentScan:组件扫描 自动发现和配置一些Bean</p>
<h3 id="restcontroller"><strong>@RestController</strong></h3>
<p>@Controller和@ResponseBody的合集 表示这个是控制器bean 是REST风格的控制器</p>
<h3 id="spring-aop"><strong>spring AOP</strong></h3>
<p>aop的动态代理是Cglib代理（aop的原理也是动态代理  从spring boot 2.0后 默认Cglib代理  之前是有JDK代理的）</p>
<p>PointCut(切点)：真正使用aop的方法</p>
<p>Advice(通知)：定义aop何时被调用 以及执行的方法</p>
<p>JoinPoint(链接点)：可以使用aop的地方（方法的前后）</p>
<h2 id="io流"><strong>IO流</strong></h2>
<p>![IO-操作方式分类](C:\Users\22215\Pictures\Saved Pictures\IO-操作方式分类.png)</p>
<h1 id="linux">Linux</h1>
<h2 id="简单的脚本书写">简单的脚本书写</h2>
<pre><code class="language-vi">vi start.sh

编写脚本 保存退出

chmod +x start.sh   赋权使其可执行

./start.sh 执行脚本
</code></pre>
<h2 id="文件-赋权">文件  赋权</h2>
<pre><code class="language-chown">chown user:market f01　　//把文件f01的主改为uesr，添加到market组
chown -R liu /usr/meng  //将目录/usr/meng及其下面的所有文件、子目录的文件主改成 liu：
</code></pre>
<hr>
<h1 id="杂的">杂的</h1>
<h3 id="和的区别"><strong>&amp;和&amp;&amp;的区别</strong></h3>
<p>都是逻辑与运算符 都可以表示与（and）</p>
<p>&amp;&amp;有短路效果 第一个表达式为false时就不会运行第二个表达式  例：对于if(str != null &amp;&amp; !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&amp;&amp;改为&amp;  所有&amp;&amp;的效率高点 好用点</p>
<h3 id="和equals"><strong>==和equals</strong></h3>
<p><mark>专门比较两个对象的地址是否相等 判断是否为同一个对象 (基本数据类型</mark>比较的是<br>
值，引用数据类型==比较的是内存地址)</p>
<p>equals  类没覆盖了equals()方法 则等价于 ==</p>
<p>覆盖了equals()方法（例如String）时 只要内容相同就相等</p>
<pre><code class="language-java">String a = new String(&quot;foo&quot;);   //a为一个引用  指向foo
String b = new String(&quot;foo&quot;);   //b为另一个引用 指向的对象内容为foo 但不是同一个对象  所有 a == b 为false  但内容相同 a.equals(b) 为true
String aa = &quot;boo&quot;;    //放在常量池中的
String bb = &quot;boo&quot;;    //在常量池中查找
</code></pre>
<p>Math.ceil(11.3)的结果为12  （向下取整）</p>
<p>Math.floor(11.6)的结果为11 （向上取整）</p>
<p>Math.round(-11.5)的结果为-11 （将原来的数 +0.5 再向下取整）</p>
<h3 id="抽象类和接口">抽象类和接口</h3>
<p>抽象类中可以有构造方法  接口中没有</p>
<p>抽象类中可以有成员变量  接口中没有</p>
<p>抽象类中有静态方法 接口中没有</p>
<p>一个类可以实现多个接口 但只能继承一个抽象类</p>
<p>接口可以多重实现  抽象类只能单继承</p>
<p>接口中的每个方法都是隐式抽象的，接口中的方法会被隐式指定为public abstract（只能是这样的 其他的会报错）不能含有静态方法或静态代码块</p>
<p>都可以被继承</p>
<p>都不能被实例化</p>
<p>都可以包含方法申明</p>
<h3 id="加密算法">加密算法</h3>
<p><code>AES</code>、<code>DES</code>、<code>3DES</code> 都是 <strong>对称</strong> 的 <strong>块加密算法</strong>，<strong>加解密</strong> 的过程是 <strong>可逆的</strong></p>
<p><code>MD5</code> 用的是 <strong>哈希函数</strong>，它的典型应用是对一段信息产生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。严格来说，<code>MD5</code> 不是一种 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。无论是多长的输入，<code>MD5</code> 都会输出长度为 <code>128bits</code> 的一个串 (通常用 <code>16</code> <strong>进制</strong> 表示为 <code>32</code> 个字符)。</p>
<p><code>RSA</code> 加密算法是目前最有影响力的 <strong>公钥加密算法</strong>，并且被普遍认为是目前 <strong>最优秀的公钥方案</strong> 之一。<code>RSA</code> 是第一个能同时用于 <strong>加密</strong> 和 <strong>数字签名</strong> 的算法，它能够 <strong>抵抗</strong> 到目前为止已知的 <strong>所有密码攻击</strong>，已被 <code>ISO</code> 推荐为公钥数据加密标准。</p>
<h3 id="java中的内存溢出的集中情况outofmemoryerror">Java中的内存溢出的集中情况OutOfMemoryError</h3>
<p><strong>PermGen space</strong></p>
<p>Java虚拟机装载类的空间不够，通过设置初始永久保存区域和最大永久保存区域的大小解决</p>
<p><strong>Java heap space</strong></p>
<p>Java虚拟机创建的对象太多，进行垃圾回收时，虚拟机分配的堆内存空间已满，可通过增加Java虚拟机中的初始堆大小和最大堆大小来解决</p>
<p><strong>unable to create new native thread</strong></p>
<p>创建过多线程会发生这种情况，控制线程的数量</p>
<h3 id="lambda表达式">lambda表达式</h3>
<p>lambda编程是建立在函数式接口得基础上的</p>
<ol>
<li>
<p>只包含一个抽象方法的接口，称为函数式接口。</p>
</li>
<li>
<p>可以通过 Lambda 表达式来创建该接口的对象。</p>
</li>
<li>
<p>可以在任意函数式接口上使用 @FunctionalInterface 注解，这样做可以检测它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</p>
</li>
</ol>
<p>在实际开发者两个比较常见的函数式接口：<strong>Runnable接口，Comparator接口</strong></p>
<p><em><strong>函数式接口的实例可以通过 lambda 表达式、 方法引用、构造方法引用来创建</strong></em></p>
<pre><code class="language-java">public class TestArray {
    
    public static void main(String[] args) {
        String[] players = {&quot;zhansgan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;, &quot;zhaoliu&quot;,  &quot;wangmazi&quot;};  

        // 1.1 使用匿名内部类根据 surname 排序 players  
        Arrays.sort(players, new Comparator&lt;String&gt;() {  
            @Override  
            public int compare(String s1, String s2) {  
                return (s1.compareTo(s2));  
            }  
        });  
        
        // 1.2 使用 lambda 排序,根据 surname  
        Arrays.sort(players, (String s1, String s2) -&gt;  s1.compareTo(s2));  
         
//================================================================================================
          
        // 2.1 使用匿名内部类根据 name lenght 排序 players  
        Arrays.sort(players, new Comparator&lt;String&gt;() {  
            @Override  
            public int compare(String s1, String s2) {  
                return (s1.length() - s2.length());  
            }  
        });  

        // 2.2使用Lambda,根据name length  
        Arrays.sort(players, (String s1, String s2) -&gt; (s1.length() - s2.length()));  
    
//==================================================================================================    
        
        // 3.1 使用匿名内部类排序 players, 根据最后一个字母  
        Arrays.sort(players, new Comparator&lt;String&gt;() {  
            @Override  
            public int compare(String s1, String s2) {  
                return (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1));  
            }  
        });  

        // 3.2 使用Lambda,根据最后一个字母
        Arrays.sort(players, (String s1, String s2) -&gt; (s1.charAt(s1.length() - 1) - s2.charAt(s2.length() - 1)));  
    }
}
</code></pre>
<h3 id="传参和接收参数">传参和接收参数</h3>
<p>@ResquestBody主要是用来接受json字符串中的数据的 GET方法没有请求体,所有使用@ResquestBody接受数据的时候,前端不能用GET进行提交而是使用POST进行提交.在后端的接受方法中@ResquestBody和@ResquestParam可以同时使用,但一个请求中@ResquestBody只能有一个,@ResquestParam可以有多个.</p>
<p><u>注</u></p>
<pre><code class="language-java">*  如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。 
* 如果参数是放在请求体中传入后台,则需要用@ResquestBody进行接受;如果不是放在请求体中的那么就需要用@ResquestParam进行接受,或者两者都不用进行接受
*  如果参数前不写@RequestParam(xxx)的话，那么前端可以没有对应的xxx名字才行，如果有xxx的话，那么就会自动匹配；没有的话，请求也能正确发送。 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日记]]></title>
        <id>https://newbe1.github.io/post/gu-dian-feng-ge</id>
        <link href="https://newbe1.github.io/post/gu-dian-feng-ge">
        </link>
        <updated>2020-01-11T09:08:56.000Z</updated>
        <content type="html"><![CDATA[<p>满洲里有象</p>
]]></content>
    </entry>
</feed>